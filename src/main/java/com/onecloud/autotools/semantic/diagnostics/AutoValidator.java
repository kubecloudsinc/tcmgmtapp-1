package com.onecloud.autotools.semantic.diagnostics;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base class for all self-validating domain objects, providing a uniform
 * template for handling validation checking. All domain objects that validate
 * themselves should extend this class and provide an implementation for the
 * performValidation() method.
 * <p>
 * The protocol for using these objects is: Semantic tier methods that accept a
 * domain object as an argument <b>must</b> call the validate() method on the
 * object before accepting it. This means that those method signatures must
 * declare that they could throw a ValidationException. Access tier code that
 * constructs these objects may also call validate() in special cases. However,
 * doing so will make it more difficult to unit test the Access tier code.
 * <p>
 * The class is designed to avoid re-running the validation logic if the
 * validate() method has been called sucessfully before.
 * <p>
 * It is a good practice to supply constructors that carry all data items needed
 * to populate the members of a self-validating domain object, and avoid mutator
 * (setter) methods. If a mutator method is absolutely needed, it should invoke
 * the invalidate() method on the domain object, since any change could impact
 * the validity of the object.
 * 
 * @author sichituk
 * 
 */
public abstract class AutoValidator {
	private boolean isValid = false;

	/**
	 * The validate() template method calls this to perform the actual
	 * validation checks on the object - subclasses must supply an
	 * implementation for this method.
	 * <p>
	 * An object is considered to be invalid unless and until this method is
	 * called.
	 * 
	 * @return An array of Diagnostic objects, each one describing a validation
	 *         problem found in the object. An effort should be made to perform
	 *         a complete set of checks and return all problems found this way.
	 *         An empty array signifies that there were no validation errors -
	 *         that is, the object is valid.
	 * 
	 */
	protected abstract Diagnostic[] performValidation();

	/**
	 * If a domain object has other embedded domain objects that are also
	 * subject to validation, override this method to identify them. Their
	 * validation results will be added to the results of the top level domain
	 * object. If validation of any embedded object fails, then the validation
	 * of the top level object also fails. In that case, the diagnostics from
	 * failed validations of embedded objects will be added to the diagnostics
	 * stored in the ValidationException generated by the validation of the top
	 * level object.
	 * <p>
	 * The default behavior is to assume that there are no embedded domain
	 * objects to validate.
	 * 
	 * @return The array of embdedded domain objects that require validation.
	 */
	protected AutoValidator[] getEmbeddedObjects() {
		return new AutoValidator[0];
	}

	/**
	 * Template method that checks whether the object is valid or not - invokes
	 * the subclass' performValidation() method to do the validity checks. If
	 * the domain object class declares that it has embedded AutoValidators (by
	 * overriding the getEmbeddedObjects() method), this method will validate
	 * those objects, too. This method is applied recursively to all levels of
	 * nested AutoValidators starting with the top level object.
	 * <p>
	 * If any embedded AutoValidator fails validation, the failure cascades
	 * outward to the top-most level. That is, an object does not pass
	 * validation unless its own validation suceeds and validation suceeds on
	 * every embedded AutoValidator.
	 * 
	 * @throws ValidationException
	 *             For any problems found inside the object - that exception
	 *             contains an array of Diagnostic objects that describe the
	 *             problems found during validation. If any embedded
	 *             AutoValidator fails validation, its diagnostics are added to
	 *             the array.
	 */
	public void validate() throws ValidationException {
		if (!isValid()) {
			List diagnostics = new ArrayList();
			if(performValidation() != null)
			diagnostics.addAll(Arrays.asList(performValidation()));
			AutoValidator[] embeddedObjects = getEmbeddedObjects();
			for (int i = 0; i < embeddedObjects.length; i++) {
				try {
					embeddedObjects[i].validate();
				} catch (ValidationException validationException) {
					diagnostics.addAll(Arrays.asList(validationException.getDiagnostics()));
				}
			}
			if (diagnostics.size() > 0) {
				throw new ValidationException((Diagnostic[]) diagnostics.toArray(new Diagnostic[diagnostics.size()]));
			}
			isValid = true;
		}
	}

	/**
	 * Interrogates the object to obtain the result of the most recent
	 * validate() method.
	 * 
	 * @return True if the validate() method has been called sucessfully, false
	 *         if the validate() method has not been called or if the validate()
	 *         method failed.
	 */
	public boolean isValid() {
		return this.isValid;
	}

	/**
	 * Marks the object as invalid - use this method if mutator methods are
	 * unavoidable in subclasses.
	 * 
	 */
	public void invalidate() {
		this.isValid = false;
	}

}
